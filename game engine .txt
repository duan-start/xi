.LOG

#发现做到后面如果对整体的开发流程不清楚的话，就会沦落到一直调试bug 和盲目的抄代码，虽然有一些网上笔记，但是却不能满足个人的问题需求，于是专门做项目记录，还有一些别人记录的学习



》》》》》》》》》》
--first day 项目的大致框架
  --entrypoint   入口点
      #正常来说main 函数是整个程序的入口点，但是对于游戏引擎来说，在游戏启动或者是引擎启动时，究竟什么决定了主要函数的位置，又是什么控制了主函数一起执行的代码
      #简而言之，就是理解main 是如何成为整个程序的入口点，还有就是整个程序执行的流程。明白了这些，我们才能随意移动main函数（设置程序的入口点，同一个解决方案下的不同项目中）

  --application layer  应用层
      #处理应用的生命周期和事件之类的（运行循环），推动事件发展，执行游戏想要执行的代码，如果事件发生（比如说是键盘输入），这些层面上的事情都是在应用层上做处理的，是一种游戏引擎运行的实际方法。

  --window layer 窗口层
    #主要是桌面平台的创建，所有图形渲染的目标的显示层
    --input 输入
      #就是指一些例如关闭窗口，按键输入等外部信息的输入
    --event 事件
       #  实际上针对每个输入，我们不可能一一去写处理，我们得有一个事件逻辑，去将类似的输入统一成一种事件，然后针对专门的事件种类去做出不同的处理逻辑（在窗口中得以表示出来）
    --事件管理器
      #信息和广播系统的功能，实际上就是一个事件被输入时，就会有相应的具体信息（比如说，我通过按键esc去退出所有窗口，这个事件的信息也是要反馈到不同层的，不然就只能退出局部了（我的理解）），对于不同的层栈来讲，可以选择性的将事件里面的信息传递下去。再比如：实体组件系统的信息传递
 
  --render 渲染
     #非常复杂，做好准备吧，这个系列是使用opengl ,实际上 后面要改进项目的话要用vuluken 实现（尤其是要做渲染这一条道路），渲染器

  --render api abstract
     #我们的引擎要支持多个渲染的接口，opengl,vluken,direct 3d,metal, (因为这里还没有做，所以我不是很明白，到时候重新回来看看)

  --debugging support 
     #日志系统，分析系统，而不依赖于vs,时间分析之类的

  --scripting 脚本
     #c#和lua ,不必考虑内存，内置的脚本语言（让使用者更见方便）

  --内存系统 memory system
     #一般是给我们调试和优化用的

  --实体组建系统，Ecs entitg -compoent system C
     #包含各种特定的组件，引擎对实体的处理
 
  --physcis 物理处理系统

  --file i/o ,vfs(虚拟文件系统)

  --可交换系统



》》》》》》》》》》
second day 第二天 项目的设置与基础配置
---创建一个GitHub上面的公开的库（license 是以允许规范之类的），(.gitnorge 是用git push 的时候会忽略的一些东西（我们不可能把本地的所有的东西都上传，实际上是构建一个脚本，然后通过这个脚本自动构建整个项目，显得更简洁）)
   #license 2.0是一定要求使用者是一个公开的项目，，旧代码在线上（到时候找一下imgui）

---创建一个项目
  #一开始通过vs创建的解决方案一般是放在一个空目录中，还有就是git clone 实际上也是要在一个空目录下的
  #路径中有空格和中文，一般是会有冲突的，比如ue 创建文件时就不能用中文，否则就是编译构建失败

---git 文件不是直接init 的，而是通过git clone 把那个github 上的readme,license ,.git 直接clone 下来的（在相同的目录下获得仓库git）  
   #这和直接的git init 有什么区别，是因为里面已经保存的license 和readme 吗
   #（clone 的已经存在的仓库的完整副本，包括所有的文件、提交历史、分支等，方便后续push）
  #通过git 访问github ,要重新配置端口，代理的端口得是clash 的端口，127.0.0.1：7890，还有就是https 协议和http两种协议的端口都要配置（其实应该只配置https 协议就可以了，只是说有时候传输会忘记加上保密协议s）

---明确这个项目的类型
    #一般的二进制文件有两种，一个是exe(可执行文件),还有一个是lib（库文件），最终呈现  出来的必然是exe 文件，但是我们首先是去写出一个库文件，这个库文件要集成所有的外部库，然后把依赖的外部库的接口都封装起来，最后构建属于自己的游戏引擎的库文件，和客户端（直接写程序和调用集成的库文件里面的东西）。所以根据这个打算，我们实际上是有两个大的项目的分类，一个是dll(动态库)，一个是exe(可执行文件)，然后这个可执行文件是做测试和调用的，实际上应该算是库里面内容的应用层。这样就实现了一个很完美的分离。
  #说白了，就是将（定义，申明）放一块，将使用放在另一块。
   #staticlib 和dll 的区别：

《《《(按博客园的说法)static静态库是包含所有的二进制链接的信息，在运行的过程中全部导入，dll类型的一般是有一个小的lib,和dll文件(其中lib 文件时导入库的信息（比如在dll里面函数的位置之类的），dll里面时具体的函数定义)，能够在编译时动态的进行链接（根据lib里面的信息）dll里面的函数定义之类的

 《《《（按cherno 的说法），传统静态库的构建，相当于就是把所有的库文件分开，然后由客户端统一调动，但是dll的话更像是一个臃肿静态库的简化版，就是把所有的依赖项全部放到一个库里，lid和dll分开存放，然后客户端的游戏只需要调用一个dll就可以了。
   #这立一共出现了三种，传统静态库，臃肿静态库和动态库。因该算是逐级优化了

---平台的配置
    #平台的删除X86 (因为有时候不知不觉跳到这里就会导致编译出错，还不如直接把不要的删了)
    #windows sdk =windows 的软件开发包（就是_declspec()之类的...）
    #文件路径以文件夹结尾，目录（文件夹）路径一般以斜杆结尾（windows \(历史遗留问题),unix /）
    #更改输出目录和中间目录
    #配置sanbox为启动文件，根据在sln 里面的文件中自动配置，实际上也可以手动去调（不是很推荐）
    #配置reference
    #由于链接库自动引用了，我们甚至都不用写include，但要通过declspec得到导出信息
 
---实际的测试
    #对于引擎内声明的函数，declspec(dllexport) 函数声明，对于客户端declspec(dllimport).  最重要的一点，一旦在某个域内声明，必然只能在这个域内进行调用，定义，就是一定要打开（用namespace 全部打开也可以，局部打开也是ok的）
   #可以在最终的bin文件里面去改动一些位置信息
   《《#插个眼，我的sandbox 的reference的链接的命令行里面怎么没有xi的lib文件



》》》》》》》》》
第三天 入口的设置
---入口点，什么是入口点
    #动态库，exe都是由入口点的，除非是静态库

    #程序执行的起始位置，在c++中，可以是全局的main函数，也可以是类的静态成员函数

    #一般是通过宏来实现复用，declspec()

    #创建一个引擎下的核心文件夹（专门用来放我们的核心逻辑）

    #创建class 的一般逻辑
       --三件套，构造函数，成员函数，析构函数（虚析构表明多态，即指针型子类删除时会优先调用子类的析构函数，避免内存泄漏），按理一般是要对=进行运算符重载的。

    #通过宏在core.h 实现对复用函数的定义，简化使用，提高复用效率

    #有一个牛的点是，对于不同平台下，预定义不同然后包含相同的函数，在宏定义的前提下完美实现了函数的导入和导出，这种复用的巧妙之出真的很厉害。

    #在Xi 核心文件外专门放一个给客户端使用的头文件，目的就是实现直接的函数的declspec(import) ,(在客户段中) 因为本质上#include 就是复制粘贴。

   #还有一件事（我现在很清楚，不知道以后会不会忘），之所以只需要这些export基类，而不需要具体实现，是因为编译本身是不需要函数的具体定义的，只要在dll里面有具体定义就行了，到时候链接的时候直接通过lib里面去找就ok了。

   #extern 的用法，好像是指明外面有一个，可以理解为会自动去外面的文件中去找（链接的时候），extern类似于一个声明，实际上也是帮助通过整个项目的编译，不然的话我们就得去include他的声明。但是这个文件是写在引擎里面的，如果要include的会看起来很乱（实际上硬要包含也是可以的），但是作为规范，我们一般不会在引擎文件里面包含客户端文件。
《《
   #接上文 ，看来链接器还是很有实力的，会把所有解决方案的.obj文件链接起来，不像编译器找个名字都找不到。（不对劲，kimi说不能）
   《 改一下答案，实际上，动态库的构建也是不会去找具体实现的，只有再客户端用到的时候才会实时的去解析函数的具体实现，此时由于客户端自己定义了该函数，所以最后才能执行成功。意义在哪？给客户端的控制权很小，甚至没有入口创建的权限
   #.gitignore
    ---和简单 #注释，忽略的目录\,忽略的文件，还有几个常见的通配符 ，*.user
     ----git status ,git add * ,git reset . （都是表示all 的意思）,git commit -m "设置入口点在引擎内部"   
    ---C:\Users\20821\Desktop\own\xi>git add *
warning: in the working copy of 'Xi/src/X/EntryPoint.h', LF will be replaced by CRLF the next time Git touches it
      #这个警报不影响具体操作，实际上是因为我有一个wsl(linux)系统，两个系统对git 的默认处理有点不一样，这里提醒我一下

---项目设置的几个重要点
    #首先是namespace ,很容易就搞混，得非常注意常见的写法。
    #头文件记得要包含全，注意X.h里面的包含顺序，还有就是如果用尖括号的话，要非常注意在sandbox 中也要附加库目录，不然查找不到。没有虚构造函数这种说法。（因为构造函数都是从基类开始使用的）
10:54 2025/1/2

---项目编写的几个规范
    在引擎项目下面分为src（自己编写的），和vendor 后面要依赖于外部的，在src 下面，一个是给客户端使用的头文件（用来加载哪些函数的声明），
	在src下面创建一个X文件，这里面全部都是自己写的，要用的文件，里面所有类的声明和定义都要放在namespace里面（规范），
	src里面放一个core.h文件，这里都是通过宏实现的很常用的函数
	至于entrypoint ，里面有主函数的进程，还有客户端函数的声明。所以并不需要包含在namespace里面（保持这个习惯吧），类的声明，定义和实例化的规范就不在讲了。



《《《《《《《《
  第四天，引入外部依赖库spdlog ,实现日志系统
    ---打印出初始化的系统信息的要求，各种信息反馈（好的产品是面向客户的），信息的来源和严重程度（根据不同的信息）。因为我们想要打印出各种东西，而不仅仅是文本内容，所以我们要有一种好的方式来格式化字符串，并加强格式化。string.format。
    ---第三方导入和维护的一般规则
        1.使用git submodule add 导入（相比于直接clone的话相当于是一个引用，完整性肯定是更好的，就是如果git clone 自己的这个项目，这一引用部分是不会包含在内的，得去原作者重新下，也就是submodule(里面是引用的地址)的原则），2.使用premakefile 或则cmakelistfile （更常见）进行维护（构建系统）
    ---导入在项目的vendor（供应商） 里面，记得在项目中添加路径（每次）
    ---封装外部库的接口
    ---日志级别的宏的处理手段
       # 不需要放在全局宏core.h里面，放在相应的log.h 里面就可以了
        #inline static function ()无需实例化，开袋即食，只能食用static 的数据，inline能够在函数调用出直接内嵌，算是给编译器的一种建议
        创建两个控制台，分别是供客户端和引擎端使用
        设置自己的格式

----项目实际配置
      static 类内的数据对象，需要在类外进行定义才会分配内存（才能使用）【很重要】，对于类内的私有数据，类内函数随便调用，同时考虑一下是不是要给类外，如果要的话就写几个类内公开的函数，返回私有变量即可。同时这里用到了一些多线程（其实就是一点）
     ---类内的数据（int...）都只是声明，可以做一些抽象的应用，但是要实际应用的话（=），一定要在类外进行定义
     ---不知道怎么回事，里面的中文好像全被我禁止了，写的注释没法保存为utf-8的格式，所以算了，英文关系也不大，还有一个core.h的依赖每次都会容易忘。
     ---函数的参数替代原则（宏），   （...）   (__VA_ARGS__)
     
14:34 2025/1/2

  


《《《《《《《
  第五天，很重要的一个工具。premakefile(用lua 语言去构建不同平台下的整体文件)
       ---premake +lua 会比cmake 简单很多，虽然后面的才是业务主流
       ---指定链接，指定包含，指定平台，指定内容，手动完成这些项目的配置是很累的，手动更改文件和文件夹（麻烦的一批）
        ---.bat文件，能能够自动访问终端并执行（既定的命令），只要给他一点权限就可以了
        ---在premake的github 里面的wiki tokens (记号或者令牌)，记录了很多可以用于使用的macros （宏）
        ---pemake：
             #这个premake作为一个可执行文件，然后在解决方案的目录下创建一个premake5.lua 文件，用来构建整个项目解决方案。这种lua 语言实际上是一个类似C语言。
         ---通过编写一个lua 文件来简单的构建整个系统--（内容有点多，所以我直接放在外面）



